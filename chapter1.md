# Часть 1

При разработке программного обеспечения, создание тестов - это одна из первоочередных задач. Почему же тестирование так важно?

* Тесты обеспечивают быструю обратную связь, позволяя Вам и Вашей команде, быстрее учиться и развиваться.
* Меньше времени уходит на отладку, следовательно Вы можете больше времени уделить написанию кода.
* Тесты являются своего рода документацией Вашего кода!
* Они улучшаются качество вашего кода, уменьшая количество ошибок.
* После рефакторинга кода, тесты покажут не нарушили ли изменения ранее работающий код, и...
* **Тесты помогут сохранить ваши нервные клетки и волосы от выпадения :\)**

Лучший способ тестировать код - использовать Разработку Через Тестирование \(Test-Driven Development, TDD\).

Ниже приведен общий принцип:

* **Пишем тест** - Тест будет проверять какую-то функцию в Вашем приложении.
* **Затем запускаем тест** - Тест должен выдать ошибку, поскольку пока не написан код, позволяющий ему выполнить без ошибок.
* **Пишем код** - чтобы тест мог выполниться без ошибок.
* **Запускаем тест** - если тест пройден успешно, Вы можете быть уверенным, что написанный код, удовлетворяет требованиям, указанным в тесте.
* **Осуществляем рефакторинг кода** - удаляем дублирующиеся части, уменьшаем большие объекты, делаем код более читаемым. Повторно запускаем тест после каждого рефакторинга.
* **Повторяем описанные ваше действия пока не будет написано все приложение** - Вот и всё!

Являясь поклонником лучших практик, мы будем использовать TDD при создании API для **списка заветных желаний \(bucketlist\)**. API позволяет осуществляет аутентификацию пользователя и реализует CRUD операции \(Create, Read, Update, Delete - операции создания, просмотра, редактирования и удаления\).

## Список заветных желаний

Цель этой статьи помочь Вам изучить что-то новое на практике. Мы создадим API для списка заветных желаний. Словосочетание BucketList происходит от идиоматической фразы «hit the bucket», что означает умереть, протянуть ноги, сыграть в ящик. Более конкретно, это перечень целей, которые Вы хотите достичь, желаний, которые Вы хотите, чтобы исполнились, то, что Вы хотите попробовать, сделать перед тем как умрете \(или «hit the bucket»\). Таким образом, это API должно помогать нам создавать и управлять этим списком.

Подытоживая, API должно позволять:

* **Создавать список заветных желаний;**
* **Получать список заветных желаний;**
* **Обновлять его,**
* **и удалять.**

Другими вспомогательными возможностями, которые будут реализованы позднее будут:

* Авторизация пользователей API;

* Поиск списков заветных желаний;

* Добавление элементов в список заветных желаний;

* Пагинация.

## В первый раз используете Python, Django?

Если Вы никогда не использовали Django раньше, то воспользуетесь этой ссылкой [Создаем своё первое приложение на Django](https://scotch.io/tutorials/build-your-first-python-and-django-application). Это прекрасная статья для начинающих.

Теперь когда мы знаем, что такое **bucketlist**, поговорим немного об инструментах, которые мы будем использовать для создания приложения.

## Django REST фреймворк

![](/images/part1/django.png)

Djanog REST фреймворк \(или сокращенно DRF\) - это мощный модуль для создания веб API. С его помощью легко создать API, основанные на моделях, с возможностью аутентификации доступные через браузер.

## Почему стоит использовать DRF?

* Аутентификация - от самой простой, базовой и основанной на сессиях до аутентификации с использованием токенов и Oauth2, DRF поддерживает все эти виды.
* Сериализация - поддержка ORM и non-ORM данных и легкая интеграция с Вашей базой данных.
* Прекрасная документация - если у Вас что-то не получается, Вы можете обратиться к его огромной документации, доступной онлайн и попросить помощи у сообщества.
* Heroku, Mozilla, Ret Hat и Eventbrite - одни из наиболее известные компаний, использующие DRF в своих API.

### Требования

Для работы DRF требуется:

* Python
* Django

Создайте и перейдите в каталог с проектом. Вы можете выбрать любое имя для него.

```
mkdir projects && $
```

Затем создайте виртуальное окружение, чтобы изолировать наш код от других приложений и системы.

```
virtualenv -p /usr/local/bin/python3 venv
```

Ключ -p позволяет указать для `virtualenv`  путь к каталогу с той версией python, которую Вы хотите использовать. Убедитесь, что Вы указали правильный путь после ключа -p. `venv` - это название Вашего виртуального окружения. Хотя Вы можете назвать Ваше виртуальное окружение как угодно, лучшей практикой считается называть его `venv` или `env`.

Активируйте Ваше виртуальное окружением следующим образом:

```
source venv/bin/activate
```

> **Примечание переводчика.** Здесь и ниже приведены команды для операционной системы Linux. Если Вы используете ОС Windows, то команда запуска виртуального окружения может отличаться от указанной выше.

Если активация прошла успешно, то в приглашении командной строки Вы увидите название виртуального окружения, например, `(venv)`. Теперь мы можем установить все что нам необходимо внутри нашего окружения.

Внутри каталога с проектом установите Django, используя pip.

```
pip install Django
```

Если pip не установлен в Вашей системе, выполните команду:

```
sudo easy_install pip
```

Чтобы знать какие пакеты требуются для создания проекта, создадим файл requirements.txt.

```
touch requirements.txt
```

Добавим все установленные пакеты в текстовый файл, используя команду `pip freeze`.

```
pip freeze > requirements.txt
```

Наконец, создадим django проект.

```
django-admin startproject djangorest
```

После выполнения этой команды, в каталоге с проектом должен был появиться новый каталог с названием `djangorest`. Вы можете выбрать любое другое название. В данный момент Вы должны иметь примерно следующую структуру каталогов:

```
djangorest
├─djangorest
│   ├── __init__.py
│   ├── settings.py
│   ├── urls.py
│   └── wsgi.py
└── manage.py
```

### Добавляем DRF

Используя pip, установите DRF

```
pip install djangorestframework
```

Чтобы мы могли использовать DRF в нашем приложении, мы должны добавить `rest_framework` в файл `settings.py`. После добавления он будет выглядеть примерно следующим образом:

```
# /djangorest/djangorest/settings.py
...

# Настройки приложения

INSTALLED_APPS = [
    'django.contrib.admin',
    'django.contrib.auth',
    'django.contrib.contenttypes',
    'django.contrib.sessions',
    'django.contrib.messages',
    'django.contrib.staticfiles', # Не забудьте добавить запятую в конце этой строки
    'rest_framework', # Добавьте эту строку в Ваш файл
]
```

## Создаем REST API приложение

В Django мы можем создать несколько приложений, которые вместе формируют одно большое приложение. Приложение в Django - это просто python пакет с множеством файлов, одним из которых является `init.py.`

Перейдите в каталог `djangorest` в терминале. В этом каталоге находится файл `manage.py`. Затем создайте приложение следующим образом:

```
python3 manage.py startapp api
```

Команда `startapp` создает новое приложение. Наше приложение называется `api`. В нём будет находится логика нашего API. После выполнения этой команды внутри каталога `djangorest` должен появиться каталог `api`.

Чтобы интегрировать наше приложение `api` в главное приложение `djangorest,` его необходимо добавить в файл `settings.py`. Давайте сделаем это прямо сейчас.

```
...

# Настройки приложения

INSTALLED_APPS = [
    'django.contrib.admin',
    'django.contrib.auth',
    'django.contrib.contenttypes',
    'django.contrib.sessions',
    'django.contrib.messages',
    'django.contrib.staticfiles',
    'rest_framework',
    'api', # Добавьте эту строку
]
```

## Начинаем кодить

### Сначала пишем тест!

В первую очередь необходимо создать модели. Но прежде чем создавать модели, нужно написать тесты. Поэтому мы напишем несколько тестов в каталоге test.py нашего приложения `api`.

```
# /api/tests.py

from django.test import TestCase
from .models import Bucketlist

class ModelTestCase(TestCase):
    """В этом классе определяется тестовый набор (test suite) для модели списка заветных желаний."""

    def setUp(self):
        """Определяем тестовый клиент и другие тестовые переменные."""
        self.bucketlist_name = "Write world class code"
        self.bucketlist = Bucketlist(name=self.bucketlist_name)

    def test_model_can_create_a_bucketlist(self):
        """Проверяем может ли модель для списка заветных желаний создавать список заветных желаний."""
        old_count = Bucketlist.objects.count()
        self.bucketlist.save()
        new_count = Bucketlist.objects.count()
        self.assertNotEqual(old_count, new_count)
```

Здесь мы импортируем тестовый случай \(test case\) из `django.test`. Тестовый случай состоит из одного теста, который проверяет может ли модель создать список заветных желаний с указанным именем.

### Затем мы определяем наши модели

Создадим пустую модель в файле `models.py`.

```
# /api/models.py

from django.db import models

class Bucketlist(models.Model):
    pass
```

Запускать тесты в Django очень легко. Мы будем использовать команду test:

```
python3 manage.py test
```

Вы должны увидеть ошибки. Ничего страшного! Ведь пока мы не заполнили поля для модели и не обновили нашу базу данных. Базой данных по умолчанию в Django является SQLite и для наших целей её будет достаточно. Кроме того нам не придется писать ни одной SQL команды при создании моделей. Django сделает все это за нас. В файле `models.py` определим поля, которые будут представлять строки таблицы в нашей базе данных.

```
# api/models.py

from django.db import models

class Bucketlist(models.Model):
    """Этот класс определяет модель для списка заветных желаний."""
    name = models.CharField(max_length=255, blank=False, unique=True)
    date_created = models.DateTimeField(auto_now_add=True)
    date_modified = models.DateTimeField(auto_now=True)

    def __str__(self):
        """Возвращаем понятное человеку представление экземпляра модели."""
        return "{}".format(self.name)
```

### Осуществляем миграции

Миграции в Django позволяют перенести изменения сделанные в моделях \(например, добавление поля, удаление модели и т. д.\) в базу данных. После того как мы создали полноценную модель, необходимо сообщить базе данных о том, что нужно создать соответствующую схему. В консоли выполните следующую команду:

```
python3 manage.py makemigrations
```

Она создаст новую миграцию , основываясь на изменениях, сделанных в модели. Затем примените миграции к вашей базе данных:

```
python3 manage.py migrate
```

Когда Вы запустите тесты, Вы должны увидеть примерно следующее:

![](/images/part1/test.png)

Тест успешно пройден! Это означает, что мы можем начать писать сериализаторы \(serializers\) для нашего приложения.

## Сериализаторы

Сериализаторы сериализуют и десериализуют данные. Так что же конкретно они делают? Процесс сериализации заключается в преобразовании сложных запросов к базе данных в понятным нам формат данных, такой как JSON или XML. Десериализация - это обратный процесс сохранения данных в базу после их валидации \(проверки данных на соответствие определенным правилам, требованиям - прим. переводчика\).

### Используйте ModelSerializers. Они действительно превосходны!

Класс `ModelSerializers` позволяет Вам автоматически создавать класс-сериализатор с полями, которые соответствуют полям модели. Это позволяет значительно уменьшить количество кода, которое необходимо написать. Создадим файл с названием `serializers.py` внутри каталога `api`. В него добавьте следующий код:

```
# api/serializers.py

from rest_framework import serializers
from .models import Bucketlist

class BucketlistSerializer(serializers.ModelSerializer):
    """Сериализатор преобразующий экземпляр модели в JSON формат."""

    class Meta:
        """Мета класс для отображения полей сериализатора в поля модели."""
        model = Bucketlist
        fields = ('id', 'name', 'date_created', 'date_modified')
        read_only_fields = ('date_created', 'date_modified')
```

## Представления




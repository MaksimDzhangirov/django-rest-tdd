# Часть 1

При разработке программного обеспечения, создание тестов - это одна из первоочередных задач. Почему же тестирование так важно?

* Тесты обеспечивают быструю обратную связь, позволяя Вам и Вашей команде, быстрее учиться и развиваться.
* Меньше времени уходит на отладку, следовательно Вы можете больше времени уделить написанию кода.
* Тесты являются своего рода документацией Вашего кода!
* Они улучшаются качество вашего кода, уменьшая количество ошибок.
* После рефакторинга кода, тесты покажут не нарушили ли изменения ранее работающий код, и...
* **Тесты помогут сохранить ваши нервные клетки и волосы от выпадения :\)**

Лучший способ тестировать код - использовать Разработку Через Тестирование \(Test-Driven Development, TDD\).

Ниже приведен общий принцип:

* **Пишем тест** - Тест будет проверять какую-то функцию в Вашем приложении.
* **Затем запускаем тест** - Тест должен выдать ошибку, поскольку пока не написан код, позволяющий ему выполнить без ошибок.
* **Пишем код** - чтобы тест мог выполниться без ошибок.
* **Запускаем тест** - если тест пройден успешно, Вы можете быть уверенным, что написанный код, удовлетворяет требованиям, указанным в тесте.
* **Осуществляем рефакторинг кода** - удаляем дублирующиеся части, уменьшаем большие объекты, делаем код более читаемым. Повторно запускаем тест после каждого рефакторинга.
* **Повторяем описанные ваше действия пока не будет написано все приложение** - Вот и всё!

Являясь поклонником лучших практик, мы будем использовать TDD при создании API для **списка заветных желаний \(bucketlist\)**. API позволяет осуществляет аутентификацию пользователя и реализует CRUD операции \(Create, Read, Update, Delete - операции создания, просмотра, редактирования и удаления\).

## Список заветных желаний

Цель этой статьи помочь Вам изучить что-то новое на практике. Мы создадим API для списка заветных желаний. Словосочетание BucketList происходит от идиоматической фразы «hit the bucket», что означает умереть, протянуть ноги, сыграть в ящик. Более конкретно, это перечень целей, которые Вы хотите достичь, желаний, которые Вы хотите, чтобы исполнились, то, что Вы хотите попробовать, сделать перед тем как умрете \(или «hit the bucket»\). Таким образом, это API должно помогать нам создавать и управлять этим списком.

Подытоживая, API должно позволять:

* **Создавать список заветных желаний;**
* **Получать список заветных желаний;**
* **Обновлять его,**
* **и удалять.**

Другими вспомогательными возможностями, которые будут реализованы позднее будут:

* Авторизация пользователей API;

* Поиск списков заветных желаний;

* Добавление элементов в список заветных желаний;

* Пагинация.

## В первый раз используете Python, Django?

Если Вы никогда не использовали Django раньше, то воспользуетесь этой ссылкой [Создаем своё первое приложение на Django](https://scotch.io/tutorials/build-your-first-python-and-django-application). Это прекрасная статья для начинающих.

Теперь когда мы знаем, что такое **bucketlist**, поговорим немного об инструментах, которые мы будем использовать для создания приложения.

## Django REST фреймворк

![](/images/part1/django.png)

Djanog REST фреймворк \(или сокращенно DRF\) - это мощный модуль для создания веб API. С его помощью легко создать API, основанные на моделях, с возможностью аутентификации доступные через браузер.

## Почему стоит использовать DRF?

* Аутентификация - от самой простой, базовой и основанной на сессиях до аутентификации с использованием токенов и Oauth2, DRF поддерживает все эти виды.
* Сериализация - поддержка ORM и non-ORM данных и легкая интеграция с Вашей базой данных.
* Прекрасная документация - если у Вас что-то не получается, Вы можете обратиться к его огромной документации, доступной онлайн и попросить помощи у сообщества.
* Heroku, Mozilla, Ret Hat и Eventbrite - одни из наиболее известные компаний, использующие DRF в своих API.

### Требования

Для работы DRF требуется:

* Python
* Django

Создайте и перейдите в каталог с проектом. Вы можете выбрать любое имя для него.

```
mkdir projects && $
```

Затем создайте виртуальное окружение, чтобы изолировать наш код от других приложений и системы.

```
virtualenv -p /usr/local/bin/python3 venv
```

Ключ -p позволяет указать для `virtualenv`  путь к каталогу с той версией python, которую Вы хотите использовать. Убедитесь, что Вы указали правильный путь после ключа -p. `venv` - это название Вашего виртуального окружения. Хотя Вы можете назвать Ваше виртуальное окружение как угодно, лучшей практикой считается называть его `venv` или `env`.

Активируйте Ваше виртуальное окружением следующим образом:

```
source venv/bin/activate
```

> **Примечание переводчика.** Здесь и ниже приведены команды для операционной системы Linux. Если Вы используете ОС Windows, то команда запуска виртуального окружения может отличаться от указанной выше.

Если активация прошла успешно, то в приглашении командной строки Вы увидите название виртуального окружения, например, `(venv)`. Теперь мы можем установить все что нам необходимо внутри нашего окружения.

Внутри каталога с проектом установите Django, используя pip.

```
pip install Django
```

Если pip не установлен в Вашей системе, выполните команду:

```
sudo easy_install pip
```

Чтобы знать какие пакеты требуются для создания проекта, создадим файл requirements.txt.

```
touch requirements.txt
```

Добавим все установленные пакеты в текстовый файл, используя команду `pip freeze`.

```
pip freeze > requirements.txt
```

Наконец, создадим django проект.

```
django-admin startproject djangorest
```

После выполнения этой команды, в каталоге с проектом должен был появиться новый каталог с названием `djangorest`. Вы можете выбрать любое другое название. В данный момент Вы должны иметь примерно следующую структуру каталогов:

```
djangorest
├─djangorest
│   ├── __init__.py
│   ├── settings.py
│   ├── urls.py
│   └── wsgi.py
└── manage.py
```

### Добавляем DRF

Используя pip, установите DRF

```
pip install djangorestframework
```

Чтобы мы могли использовать DRF в нашем приложении, мы должны добавить `rest_framework` в файл `settings.py`. После добавления он будет выглядеть примерно следующим образом:

```
# /djangorest/djangorest/settings.py
...

# Настройки приложения

INSTALLED_APPS = [
    'django.contrib.admin',
    'django.contrib.auth',
    'django.contrib.contenttypes',
    'django.contrib.sessions',
    'django.contrib.messages',
    'django.contrib.staticfiles', # Не забудьте добавить запятую в конце этой строки
    'rest_framework', # Добавьте эту строку в Ваш файл
]
```

## Создаем REST API приложение

В Django мы можем создать несколько приложений, которые вместе формируют одно большое приложение. Приложение в Django - это просто python пакет с множеством файлов, одним из которых является `__init__.py.`

Перейдите в каталог `djangorest` в терминале. В этом каталоге находится файл `manage.py`. Затем создайте приложение следующим образом:

```
python3 manage.py startapp api
```

Команда `startapp` создает новое приложение. Наше приложение называется `api`. В нём будет находится логика нашего API. После выполнения этой команды внутри каталога `djangorest` должен появиться каталог `api`.

Чтобы интегрировать наше приложение `api` в главное приложение `djangorest,` его необходимо добавить в файл `settings.py`. Давайте сделаем это прямо сейчас.

```
...

# Настройки приложения

INSTALLED_APPS = [
    'django.contrib.admin',
    'django.contrib.auth',
    'django.contrib.contenttypes',
    'django.contrib.sessions',
    'django.contrib.messages',
    'django.contrib.staticfiles',
    'rest_framework',
    'api', # Добавьте эту строку
]
```

## Начинаем кодить

### Сначала пишем тест!

В первую очередь необходимо создать модели. Но прежде чем создавать модели, нужно написать тесты. Поэтому мы напишем несколько тестов в каталоге `api`, файле `test.py` нашего приложения `api`.

```
# /api/tests.py

from django.test import TestCase
from .models import Bucketlist

class ModelTestCase(TestCase):
    """В этом классе определяется тестовый набор (test suite) для модели списка заветных желаний."""

    def setUp(self):
        """Определяем тестовый клиент и другие тестовые переменные."""
        self.bucketlist_name = "Write world class code"
        self.bucketlist = Bucketlist(name=self.bucketlist_name)

    def test_model_can_create_a_bucketlist(self):
        """Проверяем может ли модель для списка заветных желаний создавать список заветных желаний."""
        old_count = Bucketlist.objects.count()
        self.bucketlist.save()
        new_count = Bucketlist.objects.count()
        self.assertNotEqual(old_count, new_count)
```

Здесь мы импортируем тестовый случай \(test case\) из `django.test`. Тестовый случай состоит из одного теста, который проверяет может ли модель создать список заветных желаний с указанным именем.

### Затем мы определяем наши модели

Создадим пустую модель в файле `models.py`.

```
# /api/models.py

from django.db import models

class Bucketlist(models.Model):
    pass
```

Запускать тесты в Django очень легко. Мы будем использовать команду test:

```
python3 manage.py test
```

Вы должны увидеть ошибки. Ничего страшного! Ведь пока мы не заполнили поля для модели и не обновили нашу базу данных. Базой данных по умолчанию в Django является SQLite и для наших целей её будет достаточно. Кроме того нам не придется писать ни одной SQL команды при создании моделей. Django сделает все это за нас. В файле `models.py` определим поля, которые будут представлять строки таблицы в нашей базе данных.

```
# api/models.py

from django.db import models

class Bucketlist(models.Model):
    """Этот класс определяет модель для списка заветных желаний."""
    name = models.CharField(max_length=255, blank=False, unique=True)
    date_created = models.DateTimeField(auto_now_add=True)
    date_modified = models.DateTimeField(auto_now=True)

    def __str__(self):
        """Возвращаем понятное человеку представление экземпляра модели."""
        return "{}".format(self.name)
```

### Осуществляем миграции

Миграции в Django позволяют перенести изменения сделанные в моделях \(например, добавление поля, удаление модели и т. д.\) в базу данных. После того как мы создали полноценную модель, необходимо сообщить базе данных о том, что нужно создать соответствующую схему. В консоли выполните следующую команду:

```
python3 manage.py makemigrations
```

Она создаст новую миграцию , основываясь на изменениях, сделанных в модели. Затем примените миграции к вашей базе данных:

```
python3 manage.py migrate
```

Когда Вы запустите тесты, Вы должны увидеть примерно следующее:

![](/images/part1/test.png)

Тест успешно пройден! Это означает, что мы можем начать писать сериализаторы \(serializers\) для нашего приложения.

## Сериализаторы

Сериализаторы сериализуют и десериализуют данные. Так что же конкретно они делают? Процесс сериализации заключается в преобразовании сложных запросов к базе данных в понятным нам формат данных, такой как JSON или XML. Десериализация - это обратный процесс сохранения данных в базу после их валидации \(проверки данных на соответствие определенным правилам, требованиям - прим. переводчика\).

### Используйте ModelSerializers. Они действительно превосходны!

Класс `ModelSerializers` позволяет Вам автоматически создавать класс-сериализатор с полями, которые соответствуют полям модели. Это позволяет значительно уменьшить количество кода, которое необходимо написать. Создадим файл с названием `serializers.py` внутри каталога `api`. В него добавьте следующий код:

```
# api/serializers.py

from rest_framework import serializers
from .models import Bucketlist

class BucketlistSerializer(serializers.ModelSerializer):
    """Сериализатор преобразующий экземпляр модели в JSON формат."""

    class Meta:
        """Мета класс для отображения полей сериализатора в поля модели."""
        model = Bucketlist
        fields = ('id', 'name', 'date_created', 'date_modified')
        read_only_fields = ('date_created', 'date_modified')
```

## Представления

Сначала мы напишем тесты для представлений. На первый взгляд написание тестов кажется чем-то сложным. На самом деле осуществлять тестирование довольно легко, если знаешь, что необходимо реализовать. В нашем случае мы хотим создать представления, которые будут отвечать за следующее:

* Создавать список заветных желаний - обрабатываем POST запрос.
* Отображать список\(и\) заветных желаний - обрабатываем GET запрос.
* Обновлять список заветных желаний - обрабатываем PUT запрос.
* Удалять список заветных желаний - обрабатываем DELETE запрос.

Основываясь на вышеперечисленных функциях, мы знаем, что необходимо протестировать. Рассмотрим каждую функцию по отдельности. Давайте начнем с первой. Если мы хотим протестировать может ли API успешно создавать список заветных желаний , мы должны добавить следующий код в `tests.py`.

```
# api/tests.py

# Добавьте эти импорты в начало файла
from rest_framework.test import APIClient
from rest_framework import status
from django.core.urlresolvers import reverse

# Добавьте это после ModelTestCase
class ViewTestCase(TestCase):
    """Тестовый набор для представлений api."""

    def setUp(self):
        """Определяем тестовый клиент и другие тестовые переменные."""
        self.client = APIClient()
        self.bucketlist_data = {'name': 'Go to Ibiza'}
        self.response = self.client.post(
            reverse('create'),
            self.bucketlist_data,
            format="json")

    def test_api_can_create_a_bucketlist(self):
        """Тестируем возможность создания списка заветных желаний api."""
        self.assertEqual(self.response.status_code, status.HTTP_201_CREATED)
```

При запуске тест завершиться с ошибкой. Ничего удивительного, ведь мы не реализовали представления и не прописали url для обработки POST запроса.

Давайте сделаем это! В `views.py` добавьте следующий код:

```
# api/views.py

from rest_framework import generics
from .serializers import BucketlistSerializer
from .models import Bucketlist

class CreateView(generics.ListCreateAPIView):
    """Этот класс определяет поведение нашего rest api при создании нового списка."""
    queryset = Bucketlist.objects.all()
    serializer_class = BucketlistSerializer

    def perform_create(self, serializer):
        """Сохраняем post данные при создании нового списка заветных желаний."""
        serializer.save()
```

ListCreateAPIView - это общее представление, которое предоставляет обработчики для методов GET \(вывести все объекты в виде списка\) и POST.

Обратите внимание на то, что мы указали атрибуты `queryset` и `serializer_class`. Мы также объявили метод `perform_create`, который помогает сохранить новый список заветных желаний переданный методом POST.

## Настройка Url

Для того, чтобы наше приложение было законченным, мы должны указать URL в качестве "конечных точек"  нашего API.  Думайте об URL как о способе взаимодействия с внешним миром. Если кто-то хочет взаимодействовать с нашим веб-API, они должны использовать наш URL.

Создайте файл `urls.py` в каталоге api. В нем мы определим наши url-шаблоны.

```
# api/urls.py

from django.conf.urls import url, include
from rest_framework.urlpatterns import format_suffix_patterns
from .views import CreateView

urlpatterns = {
    url(r'^bucketlists/$', CreateView.as_view(), name="create"),
}

urlpatterns = format_suffix_patterns(urlpatterns)
```

`format_suffix_patters`  позволяет указать формат данных \(без какой-либо обработки, json или даже html\) для URL. Он добавляет указанный формат к каждому URL, подходящему под шаблон.

Наконец мы добавляем url в файл `urls.py` нашего главного приложения, позволяющий переадресовать запросы в наше приложение `api`. Для этого мы должны добавить `api.urls`, который мы только что создали в `urlspatterns` главного приложения. Перейдите в каталог djangorest и добавьте следующую строку в `urls.py`:

```
# djangorest/urls.py
# Это urls.py главного приложения. Не перепутайте его с файлом urls.py в каталоге api

from django.conf.urls import url, include

urlpatterns = [
    url(r'^admin/', admin.site.urls),
    url(r'^', include('api.urls')) # Добавьте эту строку
]
```

## Запускаем приложение!

Мы запустим локальный сервер с помощью Django, используя команду `runserver`:

```
python3 manage.py runserver
```

Вы должны увидеть примерно следующее в консоли после запуска команды:

![](/images/part1/test2.png)

Это сообщение означает, что локальный сервер успешно запущен.

Введите в адресной строке браузера адрес локального сервера и URL, который мы назначили для доступа к нашему API \([http://127.0.0.1:8000/bucketlists\](http://127.0.0.1:8000/bucketlists\)\). Вуаля - все работает!

![](/images/part1/create.png)Теперь введите название списка заветных желаний и нажмите на кнопку POST, чтобы проверить работу API. Вы должны увидеть примерно следующее:

![](/images/part1/create2.png)

## Отображение, обновление и удаление списка

Мы напишем ещё три теста для проверки правильности работы GET, PUT и DELETE запросов. Они выглядят следующим образом:

```
# api/tests.py

    def test_api_can_get_a_bucketlist(self):
        """Тестируем API на способность выдачи заданного списка заветных желаний."""
        bucketlist = Bucketlist.objects.get()
        response = self.client.get(
            reverse('details'),
            kwargs={'pk': bucketlist.id}, format="json")

        self.assertEqual(response.status_code, status.HTTP_200_OK)
        self.assertContains(response, bucketlist)

    def test_api_can_update_bucketlist(self):
        """Тестируем API на способность обновления заданного списка заветных желаний."""
        change_bucketlist = {'name': 'Something new'}
        res = self.client.put(
            reverse('details', kwargs={'pk': bucketlist.id}),
            change_bucketlist, format='json'
        )
        self.assertEqual(res.status_code, status.HTTP_200_OK)

    def test_api_can_delete_bucketlist(self):
        """Тестируем API на способность удаления списка заветных желаний."""
        bucketlist = Bucketlist.objects.get()
        response = self.client.delete(
            reverse('details', kwargs={'pk': bucketlist.id}),
            format='json',
            follow=True)

        self.assertEquals(response.status_code, status.HTTP_204_NO_CONTENT)
```




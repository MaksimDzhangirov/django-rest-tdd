# Часть 2

Аутентификация - одна из ключевых составляющих защиты API.

Но прежде чем продолжить, приведем краткое резюме первой части.

В первой части мы узнали как создать API для списка заветных желаний, используя TDD подход. Мы рассмотрели вопросы, связанные с написанием тестов в Django, а также узнали много нового о Django REST фреймворке.

Во второй части мы рассмотрим вспомогательные разделы. В основном мы глубоко изучим вопрос, связанный с  аутентификацией и авторизацией пользователей в нашем основанном на Django API для списка заветных желаний. Если Вы ещё прочитали первую часть, сейчас самый подходящий момент для этого, перед тем как мы продолжим.

Итак, продолжаем!

## Аутентификация или авторизация

Аутентификацию часто путают с авторизацией. Это не одно и то же.

Аутентификацию можно рассматривать как способ проверки является ли кто-то тем, кем представляется. Для этого могут использовать имя пользователя и пароль, токены, ключи и т. д. В то время как авторизация определяет какой **уровень доступа** должен быть предоставлен пользователю после успешного прохождения аутентификации.

В настоящее время наше API для списка заветных желаний является вполне работоспособным. Тем не менее, ему не хватает таких возможностей, как, например, знания кто именно создал список заветных желаний, прошел ли данный пользователь аутентификацию перед этим и имеет ли он право вносить изменения в список заветных желаний.

Давайте займемся этим.

Сначала мы реализуем аутентификацию , а затем займемся некоторыми функциями, связанными с авторизацией.

## Реализация аутентификации

Реализовать аутентификацию можно с помощью DRF API. Начнем с простого - мы будет отслеживать каждое действие пользователя.

Как нам этого достичь? В Django существует модуль User \(Пользователь\), создаваемая по умолчанию, которую мы будем использовать.

Итак, начнем.

Мы создадим поле `owner` \(владелец\) в модели для списка заветных желаний \(`Bucketlist`\). Пользователь может создать список заветных желаний - т. е. у каждого списка есть свой владелец. Таким образом, мы просто добавим поле, определяющее владельца списка, в нашу модель списка заветных желаний.

```
# rest_api/models.py

from django.db import models

class Bucketlist(models.Model):
    """Этот класс определяет модель для списка заветных желаний."""
    name = models.CharField(max_length=255, blank=False, unique=True)
    owner = models.ForeignKey('auth.User',  # ДОБАВЬТЕ ЭТО ПОЛЕ
    related_name='bucketlists', 
    on_delete=models.CASCADE) 
    date_created = models.DateTimeField(auto_now_add=True)
    date_modified = models.DateTimeField(auto_now=True)

    def __str__(self):
        """Возвращаем понятное человеку представление экземпляра модели."""
        return "{}".format(self.name)
```

Для поля `owner` используется класс `ForeignKey` \(Внешний ключ\), принимающий множество аргументов. Первый аргумент просто указывает на класс модели , с которой мы хотим создать связь.

Внешний ключ будет иметь одно из значений первичного ключа класса модели `auth.User` , создавая связь между моделями User и Bucketlist.




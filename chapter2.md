# Часть 2

Аутентификация - одна из ключевых составляющих защиты API.

Но прежде чем продолжить, приведем краткое резюме первой части.

В первой части мы узнали как создать API для списка заветных желаний, используя TDD подход. Мы рассмотрели вопросы, связанные с написанием тестов в Django, а также узнали много нового о Django REST фреймворке.

Во второй части мы рассмотрим вспомогательные разделы. В основном мы глубоко изучим вопрос, связанный с  аутентификацией и авторизацией пользователей в нашем основанном на Django API для списка заветных желаний. Если Вы ещё прочитали первую часть, сейчас самый подходящий момент для этого, перед тем как мы продолжим.

Итак, продолжаем!

## Аутентификация или авторизация

Аутентификацию часто путают с авторизацией. Это не одно и то же.

Аутентификацию можно рассматривать как способ проверки является ли кто-то тем, кем представляется. Для этого могут использовать имя пользователя и пароль, токены, ключи и т. д. В то время как авторизация определяет какой **уровень доступа** должен быть предоставлен пользователю после успешного прохождения аутентификации.

В настоящее время наше API для списка заветных желаний является вполне работоспособным. Тем не менее, ему не хватает таких возможностей, как, например, знания кто именно создал список заветных желаний, прошел ли данный пользователь аутентификацию перед этим и имеет ли он право вносить изменения в список заветных желаний.

Давайте займемся этим.

Сначала мы реализуем аутентификацию , а затем займемся некоторыми функциями, связанными с авторизацией.

## Реализация аутентификации

Реализовать аутентификацию можно с помощью DRF API. Начнем с простого - мы будет отслеживать каждое действие пользователя.

Как нам этого достичь? В Django существует модель User \(Пользователь\), создаваемая по умолчанию, которую мы будем использовать.

Итак, начнем.

Мы создадим поле `owner` \(владелец\) в модели для списка заветных желаний \(`Bucketlist`\). Пользователь может создать список заветных желаний - т. е. у каждого списка есть свой владелец. Таким образом, мы просто добавим поле, определяющее владельца списка, в нашу модель списка заветных желаний.

```
# rest_api/models.py

from django.db import models

class Bucketlist(models.Model):
    """Этот класс определяет модель для списка заветных желаний."""
    name = models.CharField(max_length=255, blank=False, unique=True)
    owner = models.ForeignKey('auth.User',  # ДОБАВЬТЕ ЭТО ПОЛЕ
    related_name='bucketlists', 
    on_delete=models.CASCADE) 
    date_created = models.DateTimeField(auto_now_add=True)
    date_modified = models.DateTimeField(auto_now=True)

    def __str__(self):
        """Возвращаем понятное человеку представление экземпляра модели."""
        return "{}".format(self.name)
```

Для поля `owner` используется класс `ForeignKey` \(Внешний ключ\), принимающий множество аргументов. Первый аргумент просто указывает на класс модели , с которой мы хотим создать связь.

Внешний ключ будет иметь одно из значений первичного ключа класса модели `auth.User` , создавая связь между моделями User и Bucketlist.

После создания поля, запустим миграции, чтобы изменения модели перенеслись в нашу базу данных.

Выполним команду

```
python3  manage.py  makemigrations  rest_api
```

Отметим, что при добавлении новых полей в существующие таблицы, Вы можете столкнуться со следующим:

![](/images/part2/m.png)

В этом сообщении говорится о том, что мы пытаемся добавить поле, значение которого может быть не равно NULL, но не указали какое значение нужно использовать. Таким образом, нужно указать значение для этого поля, которое будет вставлено в **уже существующие** строки таблицы. Если мы находимся на _стадии разработки_ , то самым простым решением будет удалить папку `migrations` внутри вашего приложения и файл `db.sqlite3`.  Это удалит ранее созданный список заветных желаний. Однако, так не получится сделать для уже работающего приложения на сервере, поскольку Вы потеряете все данные из базы данных. В этом случае выбирайте первый вариант - по умолчанию всем существующим строкам таблицы будет присвоено значение NULL для этого столбца. Но если в базе данных нет никаких данных, Вы можете спокойно удалить её и создать заново.

После этого, мы фиксируем изменения в нашей базе данных, используя команду `migrate`:

```
python3 manage.py migrate
```

## Рефакторим наши тесты

До сих пор мы не написали ни одного теста, который был проверял работоспособность системы аутентификации пользователя. Поэтому мы проведем рефакторинг уже существующих тестовых случаев.

Но сначала нам надо знать какие именно тесты написать.

Давайте проанализируем, что нам:

* нужно учесть у каждого списка заветных желаний есть свой владелец - пользователь, для которого используется стандартная модель Django - User.
* нужно убедиться, что все запросы поступают от аутентифицированных пользователей - это означает, то мы должны осуществлять аутентификацию перед отправкой HTTP запросов.

* нужно ограничить возможность создания списка заветных желаний. Его могут создавать только аутентифицированные пользователи.

* нужно ограничить доступ к существующим спискам заветных желаний. Доступ к ним должны иметь только владельцы.

Этими пунктами мы будем руководствоваться при рефакторинге наших тестов.

### Рефакторим ModelTestCase

Мы импортируем модель пользователя \(User\) по умолчанию \(`django.contrib.auth.User`\) в наш тестовый модуль, чтобы создать пользователя.

```
# rest_api/tests.py
from django.contrib.auth.models import User
```

Модель User будет использоваться для создания владельца списка заветных желаний. Мы создадим пользователя в методе `setUp`, чтобы не приходилось делать это каждый раз, когда он нам будет нужен.

```
class ModelTestCase(TestCase):
    """В этом классе определяется тестовый набор (test suite) для модели списка заветных желаний."""

    def setUp(self):
        """Определяем тестовый клиент и другие тестовые переменные."""
        user = User.objects.create(username="nerd") # ДОБАВЬТЕ ЭТУ СТРОКУ
     self.name = "Write world class code"
        # указываем владельца списка заветных желаний
        self.bucketlist = Bucketlist(name=self.name, owner=user) # ОТРЕДАКТИРУЙТЕ ТАКЖЕ ЭТУ СТРОКУ
```

Внутри метода `setUp` мы только что определили пользователя для проведения тестов, создав пользователя с именем.

> Примечание переводчика. Данный пользователь определяется в строке: user = User.objects.create\(username="nerd"\). Здесь создается пользователь с именем "nerd".

Затем мы используем экземпляр пользователя при создании списка заветных желаний. Теперь данный пользователь является владельцем этого списка.

### Рефакторим ViewsTestCase

Поскольку представления в основном работают с запросами, нам необходимо гарантировать, что только аутентифицированные и авторизованные пользователи имеют доступ к API для списка заветных желаний.

Для этого напишем следующий код:

```
# rest_api/tests.py
# здесь происходит импорт

# Здесь находится Model Test Case

class ViewTestCase(TestCase):
    """Тестовый набор для представлений api."""

    def setUp(self):
        """Определяем тестовый клиент и другие тестовые переменные."""
        user = User.objects.create(username="nerd")

        # Инициализируем клиент и принуждаем его пройти аутентификацию
        self.client = APIClient()
        self.client.force_authenticate(user=user)

        # Поскольку экземпляр модели не сериализован, используем его Id/Первичный ключ
        self.bucketlist_data = {'name': 'Go to Ibiza', 'owner': user.id}
        self.response = self.client.post(
            reverse('create'),
            self.bucketlist_data,
            format="json")

    def test_api_can_create_a_bucketlist(self):
        """Тестируем возможность создания списка заветных желаний api."""
        self.assertEqual(self.response.status_code, status.HTTP_201_CREATED)

    def test_authorization_is_enforced(self):
        """Тестируем API на способность аутентификации пользователя."""
        new_client = APIClient()
        res = new_client.get('/bucketlists/', kwargs={'pk': 3}, format="json")
        self.assertEqual(res.status_code, status.HTTP_401_UNAUTHORIZED)

    def test_api_can_get_a_bucketlist(self):
        """Тестируем API на способность выдачи заданного списка заветных желаний."""
        bucketlist = Bucketlist.objects.get(id=1)
        response = self.client.get(
            '/bucketlists/',
            kwargs={'pk': bucketlist.id}, format="json")

        self.assertEqual(response.status_code, status.HTTP_200_OK)
        self.assertContains(response, bucketlist)

    def test_api_can_update_bucketlist(self):
        """Тестируем API на способность обновления заданного списка заветных желаний."""
        bucketlist = Bucketlist.objects.get()
        change_bucketlist = {'name': 'Something new'}
        res = self.client.put(
            reverse('details', kwargs={'pk': bucketlist.id}),
            change_bucketlist, format='json'
        )
        self.assertEqual(res.status_code, status.HTTP_200_OK)

    def test_api_can_delete_bucketlist(self):
        """Тестируем API на способность удаления списка заветных желаний."""
        bucketlist = Bucketlist.objects.get()
        response = self.client.delete(
            reverse('details', kwargs={'pk': bucketlist.id}),
            format='json',
            follow=True)
        self.assertEquals(response.status_code, status.HTTP_204_NO_CONTENT)
```

Мы инициализировали APIClient и заставили его пройти аутентификацию. Это обеспечивает защиту API. Также был учтен владелец списка заветных желаний. Кроме того, обратили ли Вы внимание, что мы использовали self.client в каждом тестовом методе вместо создания каждый раз нового? Это гарантирует, что каждый раз используется аутентифицированный клиент. Многократное использование - это хорошая практика. :\) Прекрасно, что мы ей воспользовались.

Запустите тесты. Сейчас они должны _завершиться с ошибкой_.

```
python3  manage.py  test  rest_api
```

Наш следующий шаг - рефакторинг нашего кода, чтобы эти тесты завершались без ошибок.

## Как нам пройти эти тесты?!

### Сначала добавляем пользователя




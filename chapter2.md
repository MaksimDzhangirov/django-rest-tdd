# Часть 2

Аутентификация - одна из ключевых составляющих защиты API.

Но прежде чем продолжить, приведем краткое резюме первой части.

В первой части мы узнали как создать API для списка заветных желаний, используя TDD подход. Мы рассмотрели вопросы, связанные с написанием тестов в Django, а также узнали много нового о Django REST фреймворке.

Во второй части мы рассмотрим вспомогательные разделы. В основном мы глубоко изучим вопрос, связанный с  аутентификацией и авторизацией пользователей в нашем основанном на Django API для списка заветных желаний. Если Вы ещё прочитали первую часть, сейчас самый подходящий момент для этого, перед тем как мы продолжим.

Итак, продолжаем!

## Аутентификация или авторизация

Аутентификацию часто путают с авторизацией. Это не одно и то же.

Аутентификацию можно рассматривать как способ проверки является ли кто-то тем, кем представляется. Для этого могут использовать имя пользователя и пароль, токены, ключи и т. д. В то время как авторизация определяет какой **уровень доступа** должен быть предоставлен пользователю после успешного прохождения аутентификации.

В настоящее время наше API для списка заветных желаний является вполне работоспособным. Тем не менее, ему не хватает таких возможностей, как, например, знания кто именно создал список заветных желаний, прошел ли данный пользователь аутентификацию перед этим и имеет ли он право вносить изменения в список заветных желаний.

Давайте займемся этим.

Сначала мы реализуем аутентификацию , а затем займемся некоторыми функциями, связанными с авторизацией.

## Реализация аутентификации

Реализовать аутентификацию можно с помощью DRF API. Начнем с простого - мы будет отслеживать каждое действие пользователя.

Как нам этого достичь? В Django существует модель User \(Пользователь\), создаваемая по умолчанию, которую мы будем использовать.

Итак, начнем.

Мы создадим поле `owner` \(владелец\) в модели для списка заветных желаний \(`Bucketlist`\). Пользователь может создать список заветных желаний - т. е. у каждого списка есть свой владелец. Таким образом, мы просто добавим поле, определяющее владельца списка, в нашу модель списка заветных желаний.

```
# rest_api/models.py

from django.db import models

class Bucketlist(models.Model):
    """Этот класс определяет модель для списка заветных желаний."""
    name = models.CharField(max_length=255, blank=False, unique=True)
    owner = models.ForeignKey('auth.User',  # ДОБАВЬТЕ ЭТО ПОЛЕ
    related_name='bucketlists', 
    on_delete=models.CASCADE) 
    date_created = models.DateTimeField(auto_now_add=True)
    date_modified = models.DateTimeField(auto_now=True)

    def __str__(self):
        """Возвращаем понятное человеку представление экземпляра модели."""
        return "{}".format(self.name)
```

Для поля `owner` используется класс `ForeignKey` \(Внешний ключ\), принимающий множество аргументов. Первый аргумент просто указывает на класс модели , с которой мы хотим создать связь.

Внешний ключ будет иметь одно из значений первичного ключа класса модели `auth.User` , создавая связь между моделями User и Bucketlist.

После создания поля, запустим миграции, чтобы изменения модели перенеслись в нашу базу данных.

Выполним команду

```
python3  manage.py  makemigrations  rest_api
```

Отметим, что при добавлении новых полей в существующие таблицы, Вы можете столкнуться со следующим:

![](/images/part2/m.png)

В этом сообщении говорится о том, что мы пытаемся добавить поле, значение которого может быть не равно NULL, но не указали какое значение нужно использовать. Таким образом, нужно указать значение для этого поля, которое будет вставлено в **уже существующие** строки таблицы. Если мы находимся на _стадии разработки_ , то самым простым решением будет удалить папку `migrations` внутри вашего приложения и файл `db.sqlite3`.  Это удалит ранее созданный список заветных желаний. Однако, так не получится сделать для уже работающего приложения на сервере, поскольку Вы потеряете все данные из базы данных. В этом случае выбирайте первый вариант - по умолчанию всем существующим строкам таблицы будет присвоено значение NULL для этого столбца. Но если в базе данных нет никаких данных, Вы можете спокойно удалить её и создать заново.

После этого, мы фиксируем изменения в нашей базе данных, используя команду `migrate`:

```
python3 manage.py migrate
```

## Рефакторим наши тесты

До сих пор мы не написали ни одного теста, который был проверял работоспособность системы аутентификации пользователя. Поэтому мы проведем рефакторинг уже существующих тестовых случаев.

Но сначала нам надо знать какие именно тесты написать.

Давайте проанализируем, что нам:

* нужно учесть у каждого списка заветных желаний есть свой владелец - пользователь, для которого используется стандартная модель Django - User.
* нужно убедиться, что все запросы поступают от аутентифицированных пользователей - это означает, то мы должны осуществлять аутентификацию перед отправкой HTTP запросов.

* нужно ограничить возможность создания списка заветных желаний. Его могут создавать только аутентифицированные пользователи.

* нужно ограничить доступ к существующим спискам заветных желаний. Доступ к ним должны иметь только владельцы.

Этими пунктами мы будем руководствоваться при рефакторинге наших тестов.

### Рефакторим ModelTestCase

Мы импортируем модель пользователя \(User\) по умолчанию \(`django.contrib.auth.User`\) в наш тестовый модуль, чтобы создать пользователя.

```
# rest_api/tests.py
from django.contrib.auth.models import User
```

Модель User будет использоваться для создания владельца списка заветных желаний. Мы создадим пользователя в методе `setUp`, чтобы не приходилось делать это каждый раз, когда он нам будет нужен.

```
class ModelTestCase(TestCase):
    """В этом классе определяется тестовый набор (test suite) для модели списка заветных желаний."""

    def setUp(self):
        """Определяем тестовый клиент и другие тестовые переменные."""
        user = User.objects.create(username="nerd") # ДОБАВЬТЕ ЭТУ СТРОКУ
     self.name = "Write world class code"
        # указываем владельца списка заветных желаний
        self.bucketlist = Bucketlist(name=self.name, owner=user) # ОТРЕДАКТИРУЙТЕ ТАКЖЕ ЭТУ СТРОКУ
```

Внутри метода `setUp` мы только что определили пользователя для проведения тестов, создав пользователя с именем.

> Примечание переводчика. Данный пользователь определяется в строке: user = User.objects.create\(username="nerd"\). Здесь создается пользователь с именем "nerd".

Затем мы используем экземпляр пользователя при создании списка заветных желаний. Теперь данный пользователь является владельцем этого списка.

### Рефакторим ViewsTestCase

Поскольку представления в основном работают с запросами, нам необходимо гарантировать, что только аутентифицированные и авторизованные пользователи имеют доступ к API для списка заветных желаний.

Для этого напишем следующий код:

```
# rest_api/tests.py
# здесь происходит импорт

# Здесь находится Model Test Case

class ViewTestCase(TestCase):
    """Тестовый набор для представлений api."""

    def setUp(self):
        """Определяем тестовый клиент и другие тестовые переменные."""
        user = User.objects.create(username="nerd")

        # Инициализируем клиент и принуждаем его пройти аутентификацию
        self.client = APIClient()
        self.client.force_authenticate(user=user)

        # Поскольку экземпляр модели не сериализован, используем его Id/Первичный ключ
        self.bucketlist_data = {'name': 'Go to Ibiza', 'owner': user.id}
        self.response = self.client.post(
            reverse('create'),
            self.bucketlist_data,
            format="json")

    def test_api_can_create_a_bucketlist(self):
        """Тестируем возможность создания списка заветных желаний api."""
        self.assertEqual(self.response.status_code, status.HTTP_201_CREATED)

    def test_authorization_is_enforced(self):
        """Тестируем API на способность аутентификации пользователя."""
        new_client = APIClient()
        res = new_client.get('/bucketlists/', kwargs={'pk': 3}, format="json")
        self.assertEqual(res.status_code, status.HTTP_401_UNAUTHORIZED)

    def test_api_can_get_a_bucketlist(self):
        """Тестируем API на способность выдачи заданного списка заветных желаний."""
        bucketlist = Bucketlist.objects.get(id=1)
        response = self.client.get(
            '/bucketlists/',
            kwargs={'pk': bucketlist.id}, format="json")

        self.assertEqual(response.status_code, status.HTTP_200_OK)
        self.assertContains(response, bucketlist)

    def test_api_can_update_bucketlist(self):
        """Тестируем API на способность обновления заданного списка заветных желаний."""
        bucketlist = Bucketlist.objects.get()
        change_bucketlist = {'name': 'Something new'}
        res = self.client.put(
            reverse('details', kwargs={'pk': bucketlist.id}),
            change_bucketlist, format='json'
        )
        self.assertEqual(res.status_code, status.HTTP_200_OK)

    def test_api_can_delete_bucketlist(self):
        """Тестируем API на способность удаления списка заветных желаний."""
        bucketlist = Bucketlist.objects.get()
        response = self.client.delete(
            reverse('details', kwargs={'pk': bucketlist.id}),
            format='json',
            follow=True)
        self.assertEquals(response.status_code, status.HTTP_204_NO_CONTENT)
```

Мы инициализировали APIClient и заставили его пройти аутентификацию. Это обеспечивает защиту API. Также был учтен владелец списка заветных желаний. Кроме того, обратили ли Вы внимание, что мы использовали self.client в каждом тестовом методе вместо создания каждый раз нового? Это гарантирует, что каждый раз используется аутентифицированный клиент. Многократное использование - это хорошая практика. :\) Прекрасно, что мы ей воспользовались.

Запустите тесты. Сейчас они должны _завершиться с ошибкой_.

```
python3  manage.py  test  rest_api
```

Наш следующий шаг - рефакторинг нашего кода, чтобы эти тесты завершались без ошибок.

## Как нам пройти эти тесты?!

### Сначала добавляем пользователя

Чаще всего любые изменения , сделанные в Вашей модели, должны быть отражены в Ваших сериализаторах. Это связано с тем, что сериализаторы непосредственно взаимодействуют с моделью , преобразовывая запросы  к базе данных в JSON и наоборот.

Давайте отредактируем наш сериализатор для списка заветных желаний. Просто перейдите в файл `serializers.py` и добавьте новое поле, которую лучше всего назвать `owner`. Оно будет определять владельца списка.

```
# rest_api/serializers.py

class BucketlistSerializer(serializers.ModelSerializer):
    """Сериализатор, преобразующий экземпляр модели в JSON формат."""

    owner = serializers.ReadOnlyField(source='owner.username') # ДОБАВЬТЕ ЭТУ СТРОКУ

    class Meta:
        """Класс для отображения этого сериализатора в модель и её поля."""
        model = Bucketlist
        fields = ('id', 'name', 'owner', 'date_created', 'date_modified') # ДОБАВЛЯЕМ 'owner'
        read_only_fields = ('date_created', 'date_modified')
```

Поле `owner` доступно только для чтения, поэтому пользователь, использующий наше API не сможет изменить владельца списка заветных желаний.

Запустим приложение и посмотрим работает ли оно: Запустите сервер `python manage.py runserver`

Получив доступ к приложению через localhost, мы должны увидеть примерно следующее:

![](/images/part2/create3.png)Теперь нужно как то сохранить владельца при создании нового списка заветных желаний. Сохранение списка осуществляется в классе `СreateView` , который определен в `views.py`.  Отредактируем наш класс `CreateView`, добавив в него метод `perform_create(self, serializer)`. Этот метод позволяет управлять процессом сохранения нашего сериализатора.

```
# rest_api/views.py

# Мы внутри класса CreateView
...

    def perform_create(self, serializer):
            """Сохраняем POST данные при создании нового списка заветных желаний."""
            serializer.save(owner=self.request.user) # Добавьте owner=self.request.user
```

`serializer.save()` принимает в качестве аргументов поля. Здесь мы указали в качестве аргумента `owner`. Почему? Потому что это одно из полей нашего сериализатора - таким образом мы указываем владельца в методе `save` сериализатора, что позволяет сохранить список заветных желаний, владельцем которого будет текущий пользователь.

Теперь при попытке создания списка, мы должны получить следующую ошибку:

![](/images/part2/valueerror.png)

Произошла ошибка при сохранении в базе данных. Почему произошла именно ValueError \(Ошибка в значении\)? Хороший вопрос - это связано с тем, что мы пытаемся сохранить список заветных желаний из браузера, _не указав при этом владельца_!

Для нашего нового поля `owner`, которое не должно быть равно NULL, необходимо указать значение, прежде чем сериализатор сможет проверить и сохранить список заветных желаний.

Давайте сразу же исправим эту ошибку.

В файл `urls.py` добавим путь, с помощью которого пользователь сможет залогиниться в наше API, прежде чем создавать список заветных желаний. Эту необходимо, потому что у списка должен быть владелец, таким образом вошедший в систему \(залогиненный\) пользователь сможет создать список.

```
# rest_api/urls.py
# Здесь находится import

urlpatterns = {
    url(r'^auth/', include('rest_framework.urls', # ДОБАВЬТЕ ЭТОТ URL
                               namespace='rest_framework')), 
    url(r'^bucketlists/$', CreateView.as_view(), name="create"),
    url(r'^bucketlists/(?P<pk>[0-9]+)/$',
        DetailsView.as_view(), name="details"),
}

urlpatterns = format_suffix_patterns(urlpatterns)
```



